// ============================================================
// ТЕМА: Навігаційні методи - children(), parent(), closest(), siblings(), prev()
// ОПИС: Демонстрація методів для навігації по DOM дереву
//       та пошуку елементів відносно поточного елемента
// ============================================================

describe('Навігаційні методи - рух по DOM дереву', () => {
  // Підготовка: відкриваємо сторінку та додаємо тестові дані
  beforeEach(() => {
    cy.visit('/')
    cy.get('.new-todo').type('Задача 1{enter}')
    cy.get('.new-todo').type('Задача 2{enter}')
    cy.get('.new-todo').type('Задача 3{enter}')
  })

  // Тест 1: children() - знаходження дочірніх елементів
  // children() - знаходить тільки прямі дочірні елементи (не всіх нащадків)
  it('має знайти дочірні елементи через children()', () => {
    // cy.get('.todo-list') - знаходимо батьківський елемент
    // .children() - знаходимо всі прямі дочірні елементи
    // У TodoMVC це будуть елементи <li>
    cy.get('.todo-list')
      .children()
      // Перевіряємо, що знайдено 3 дочірні елементи
      .should('have.length', 3)
    
    // children() з селектором - знаходить тільки дочірні елементи, що відповідають селектору
    // .children('li') - знаходить тільки дочірні li елементи
    cy.get('.todo-list')
      .children('li')
      .should('have.length', 3)
  })

  // Тест 2: parent() - знаходження батьківського елемента
  // parent() - знаходить безпосередньо батьківський елемент
  it('має знайти батьківський елемент через parent()', () => {
    // cy.get('.todo-list li .toggle') - знаходимо чекбокс всередині задачі
    // .first() - беремо перший чекбокс
    // .closest('li') - знаходимо найближчий li елемент (більш надійно за parent())
    // Це корисно, коли знаємо дочірній елемент, але потрібен батьківський
    cy.get('.todo-list li .toggle')
      .first()
      .closest('li')
      // Перевіряємо, що це дійсно елемент li
      .should('have.prop', 'tagName', 'LI')
    
    // parent() з селектором - знаходить батьківський елемент, що відповідає селектору
    // .parent('li') - знаходить батьківський li (якщо він є)
    // Використовуємо closest() для надійності, бо структура DOM може бути різною
    cy.get('.todo-list li .toggle')
      .first()
      .closest('li')
      .should('exist')
  })

  // Тест 3: closest() - знаходження найближчого предка
  // closest() - знаходить найближчий предок (батько, дідусь тощо), що відповідає селектору
  it('має знайти найближчий предок через closest()', () => {
    // cy.get('.toggle') - знаходимо чекбокс (глибоко вкладений елемент)
    // .closest('li') - знаходимо найближчий предок li
    // closest() шукає серед самого елемента та всіх його предків
    cy.get('.toggle')
      .first()
      .closest('li')
      .should('exist')
      .should('contain', 'Задача 1')
    
    // closest() корисний, коли не знаємо точну структуру DOM
    // Він знайде найближчий елемент, що відповідає умові
    cy.get('.toggle')
      .first()
      .closest('.todo-list')
      .should('exist')
  })

  // Тест 4: siblings() - знаходження сусідніх (братських) елементів
  // siblings() - знаходить всі елементи на тому ж рівні (брати та сестри)
  it('має знайти сусідні елементи через siblings()', () => {
    // cy.get('.todo-list li').first() - знаходимо перший елемент списку
    // .siblings() - знаходимо всі інші елементи на тому ж рівні
    // Це будуть другий та третій елементи списку
    cy.get('.todo-list li')
      .first()
      .siblings()
      // Має бути 2 сусідніх елементи
      .should('have.length', 2)
    
    // siblings() з селектором - знаходить тільки сусідні елементи, що відповідають селектору
    // .siblings('li') - знаходить тільки сусідні li елементи
    cy.get('.todo-list li')
      .first()
      .siblings('li')
      .should('have.length', 2)
  })

  // Тест 5: prev() - знаходження попереднього сусіднього елемента
  // prev() - знаходить безпосередньо попередній елемент на тому ж рівні
  it('має знайти попередній елемент через prev()', () => {
    // cy.get('.todo-list li').eq(1) - знаходимо другий елемент (індекс 1)
    // .prev() - знаходимо попередній елемент (перший)
    // prev() знаходить тільки один елемент (безпосередньо попередній)
    cy.get('.todo-list li')
      .eq(1)
      .prev()
      // Перевіряємо, що це перший елемент
      .should('contain', 'Задача 1')
    
    // prev() з селектором - знаходить попередній елемент, що відповідає селектору
    // .prev('li') - знаходить попередній li елемент
    cy.get('.todo-list li')
      .eq(2)
      .prev('li')
      .should('contain', 'Задача 2')
  })

  // Тест 6: Комбінація навігаційних методів
  // Можна комбінувати різні методи для складних навігацій
  it('має комбінувати навігаційні методи', () => {
    // Складний приклад: знаходимо перший li, потім його сусідні елементи
    // Використовуємо closest() для надійності замість parent()
    cy.get('.todo-list li')
      .first()
      // Знаходимо сусідні елементи
      .siblings('li')
      // Беремо перший сусідній елемент
      .first()
      // Перевіряємо, що це друга задача
      .should('contain', 'Задача 2')
  })

  // Тест 7: Практичний приклад - навігація для взаємодії
  // Використання навігаційних методів у реальних сценаріях
  it('має використовувати навігацію для взаємодії з елементами', () => {
    // Знаходимо чекбокс другої задачі через навігацію
    // cy.get('.todo-list li').first() - перша задача
    // .siblings('li').first() - перша сусідня задача (друга)
    // .find('.toggle') - чекбокс всередині неї
    cy.get('.todo-list li')
      .first()
      .siblings('li')
      .first()
      .find('.toggle')
      .check()
    
    // Перевіряємо, що друга задача відмічена
    cy.get('.todo-list li')
      .eq(1)
      .should('have.class', 'completed')
  })
})

// ============================================================
// ВАЖЛИВІ ЗАУВАЖЕННЯ про навігаційні методи:
// ============================================================
// children() - тільки прямі дочірні елементи (не всі нащадки)
// parent() - безпосередньо батьківський елемент
// closest() - найближчий предок, що відповідає селектору
// siblings() - всі сусідні елементи на тому ж рівні
// prev() - безпосередньо попередній сусідній елемент
//
// Всі ці методи працюють з вже знайденим елементом
// Вони дозволяють навігувати по DOM дереву відносно поточного елемента
// ============================================================
