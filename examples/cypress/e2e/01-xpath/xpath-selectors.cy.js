// ============================================================
// ТЕМА: XPath Селектори в Cypress
// ОПИС: Демонстрація використання XPath селекторів через плагін cypress-xpath
//       XPath дозволяє більш гнучкий пошук елементів, але менш ефективний за CSS
// ============================================================

describe('XPath Селектори - альтернатива CSS', () => {
  // Підготовка: відкриваємо сторінку перед кожним тестом
  beforeEach(() => {
    cy.visit('/')
  })

  // Тест 1: Базове використання XPath
  // cy.xpath() - команда, яка додається плагіном cypress-xpath
  it('має знайти елементи за допомогою базових XPath селекторів', () => {
    // cy.xpath('//h1') - знаходить всі заголовки h1 на сторінці
    // Подвійний слеш // означає "шукати на будь-якому рівні DOM дерева"
    // Одинарний слеш / означав би "тільки прямі дочірні елементи"
    cy.xpath('//h1')
      // Перевіряємо, що знайдено заголовок з текстом "todos"
      .should('contain', 'todos')
    
    // cy.xpath('//input[@type="text"]') - знаходить input з атрибутом type="text"
    // @type - синтаксис XPath для посилання на атрибути
    // Квадратні дужки [] використовуються для умов
    cy.xpath('//input[@type="text"]')
      .should('be.visible')
  })

  // Тест 2: XPath з текстовим вмістом
  // XPath дуже зручний для пошуку елементів за текстом
  it('має знайти елементи за текстовим вмістом через XPath', () => {
    // cy.xpath('//h1[contains(text(), "todos")]') - знаходить h1, що містить текст "todos"
    // contains() - функція XPath для часткового співпадіння тексту
    // text() - функція для отримання текстового вмісту елемента
    cy.xpath('//h1[contains(text(), "todos")]')
      .should('exist')
    
    // Додаємо задачу для тестування
    cy.get('.new-todo').type('Тестова задача{enter}')
    
    // cy.xpath('//li[contains(., "Тестова")]') - знаходить li з текстом "Тестова"
    // Крапка (.) в XPath означає поточний вузол та всі його нащадки (включаючи текст)
    // Це зручніше, ніж CSS, коли потрібно шукати за текстом
    cy.xpath('//li[contains(., "Тестова")]')
      .should('exist')
      .should('contain', 'Тестова задача')
  })

  // Тест 3: XPath з комбінацією умов
  // XPath дозволяє комбінувати кілька умов для точнішого пошуку
  it('має використовувати XPath з множинними умовами', () => {
    // Додаємо кілька задач
    cy.get('.new-todo').type('Задача 1{enter}')
    cy.get('.new-todo').type('Задача 2{enter}')
    
    // cy.xpath('(//li)[1]') - знаходить перший li на сторінці
    // Дужки () групують вираз, [1] вибирає перший елемент
    // Увага: в XPath нумерація починається з 1, а не з 0!
    cy.xpath('(//ul[@class="todo-list"]//li)[1]')
      .should('contain', 'Задача 1')
    
    // cy.xpath('(//li)[last()]') - знаходить останній елемент
    // last() - функція XPath для вибору останнього елемента
    cy.xpath('(//ul[@class="todo-list"]//li)[last()]')
      .should('contain', 'Задача 2')
  })

  // Тест 4: XPath для навігації по DOM дереву
  // XPath дозволяє навігувати по відношеннях між елементами
  it('має використовувати XPath для навігації по DOM дереву', () => {
    // Додаємо задачу
    cy.get('.new-todo').type('Задача для навігації{enter}')
    
    // cy.xpath('//li[contains(., "навігації")]//input') - знаходить input всередині li
    // Крапка (.) означає поточний вузол та всі нащадки (включаючи текст)
    // Подвійний слеш // означає "будь-який нащадок на будь-якому рівні"
    cy.xpath('//li[contains(., "навігації")]//input[@type="checkbox"]')
      .should('exist')
      // Перевіряємо, що це саме чекбокс для відмітки задачі
      .should('have.class', 'toggle')
    
    // cy.xpath('//li[contains(., "навігації")]/div') - знаходить прямі дочірні div
    // Одинарний слеш / означає "тільки прямі дочірні елементи"
    cy.xpath('//li[contains(., "навігації")]/div')
      .should('exist')
  })

  // Тест 5: XPath з функціями
  // XPath має багато вбудованих функцій для роботи з елементами
  it('має використовувати XPath функції для складних пошуків', () => {
    // Додаємо кілька задач
    cy.get('.new-todo').type('Перша{enter}')
    cy.get('.new-todo').type('Друга{enter}')
    cy.get('.new-todo').type('Третя{enter}')
    
    // cy.xpath('(//ul[@class="todo-list"]//li)[2]') - знаходить другий елемент
    // Дужки () групують вираз, [2] вибирає другий елемент
    // Увага: в XPath нумерація починається з 1!
    cy.xpath('(//ul[@class="todo-list"]//li)[2]')
      .should('contain', 'Друга')
    
    // cy.xpath('(//ul[@class="todo-list"]//li)[position()>1]') - знаходить всі елементи після першого
    // Можна використовувати оператори порівняння: >, <, >=, <=, =
    cy.xpath('(//ul[@class="todo-list"]//li)[position()>1]')
      // Перевіряємо, що знайдено 2 елементи (другий та третій)
      .should('have.length', 2)
  })

  // Тест 6: XPath для пошуку за атрибутами з частковим співпадінням
  // XPath дозволяє більш гнучкий пошук за атрибутами
  it('має використовувати XPath для пошуку за атрибутами', () => {
    // cy.xpath('//input[starts-with(@placeholder, "What")]') - знаходить input, 
    // у якого placeholder починається з "What"
    // starts-with() - функція для перевірки початку рядка
    cy.xpath('//input[starts-with(@placeholder, "What")]')
      .should('exist')
      .should('be.visible')
    
    // cy.xpath('//input[contains(@class, "new-todo")]') - знаходить input,
    // у якого клас містить "new-todo"
    // contains() працює не тільки з текстом, але й з атрибутами
    cy.xpath('//input[contains(@class, "new-todo")]')
      .should('exist')
  })
})

// ============================================================
// ВАЖЛИВІ ЗАУВАЖЕННЯ про XPath:
// ============================================================
// 1. XPath менш ефективний за CSS селектори - використовуйте його обережно
// 2. Плагін cypress-xpath є deprecated, але все ще працює
// 3. Віддавайте перевагу CSS селекторам, якщо можливо
// 4. XPath корисний для складних пошуків за текстом або структурою
// 5. XPath може бути менш стабільним при зміні структури DOM
// ============================================================
