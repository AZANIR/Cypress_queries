// ============================================================
// ТЕМА: Порівняння CSS та XPath селекторів
// ОПИС: Демонстрація різниці між CSS та XPath підходами
//       та коли краще використовувати кожен з них
// ============================================================

describe('CSS vs XPath - порівняння підходів', () => {
  // Підготовка: відкриваємо сторінку та додаємо тестові дані
  beforeEach(() => {
    cy.visit('/')
    // Додаємо кілька задач для порівняння
    cy.get('.new-todo').type('Задача 1{enter}')
    cy.get('.new-todo').type('Задача 2{enter}')
    cy.get('.new-todo').type('Задача 3{enter}')
  })

  // Тест 1: Пошук за класом - CSS перевага
  // CSS селектори більш читабельні та ефективні для простих випадків
  it('має показати переваги CSS для пошуку за класом', () => {
    // CSS підхід: простий та читабельний
    // cy.get('.todo-list') - знаходить елемент за класом
    // Це стандартний спосіб в Cypress
    cy.get('.todo-list')
      .should('exist')
    
    // XPath підхід: більш складний для того ж результату
    // cy.xpath('//ul[contains(@class, "todo-list")]') - знаходить ul з класом "todo-list"
    // contains() потрібен, бо елемент може мати кілька класів
    cy.xpath('//ul[contains(@class, "todo-list")]')
      .should('exist')
    
    // Висновок: для пошуку за класом CSS набагато простіший
  })

  // Тест 2: Пошук за текстом - XPath перевага
  // XPath більш зручний для пошуку елементів за текстовим вмістом
  it('має показати переваги XPath для пошуку за текстом', () => {
    // CSS підхід: потрібно використовувати cy.contains()
    // cy.contains() - окрема команда Cypress для пошуку за текстом
    // Це не CSS селектор, а спеціальна команда
    cy.contains('.todo-list li', 'Задача 1')
      .should('exist')
    
    // XPath підхід: пошук за текстом прямо в селекторі
    // cy.xpath('//li[contains(., "Задача 1")]') - все в одному виразі
    // Крапка (.) в XPath означає поточний вузол та всі його нащадки
    // Більш гнучкий та потужний для складних умов
    cy.xpath('//li[contains(., "Задача 1")]')
      .should('exist')
    
    // Висновок: XPath зручніший для пошуку за текстом
  })

  // Тест 3: Пошук за позицією - обидва підходи
  // Обидва підходи підтримують пошук за позицією, але по-різному
  it('має показати різницю в пошуку за позицією', () => {
    // CSS підхід: використання псевдокласів
    // cy.get('.todo-list li:first-child') - перший елемент
    // Псевдокласи CSS - стандартний спосіб
    cy.get('.todo-list li:first-child')
      .should('contain', 'Задача 1')
    
    // CSS: другий елемент через nth-child
    cy.get('.todo-list li:nth-child(2)')
      .should('contain', 'Задача 2')
    
    // XPath підхід: використання функції position()
    // cy.xpath('//li[position()=1]') - перший елемент
    // Більш гнучкий для складних умов
    cy.xpath('//li[position()=1]')
      .should('contain', 'Задача 1')
    
    // XPath: другий елемент
    cy.xpath('//li[position()=2]')
      .should('contain', 'Задача 2')
    
    // Висновок: обидва підходи працюють, CSS простіший для базових випадків
  })

  // Тест 4: Пошук за атрибутами - CSS перевага
  // CSS селектори більш читабельні для роботи з атрибутами
  it('має показати переваги CSS для пошуку за атрибутами', () => {
    // CSS підхід: простий синтаксис для атрибутів
    // cy.get('[type="text"]') - знаходить елементи з type="text"
    // Квадратні дужки [] - стандартний синтаксис CSS для атрибутів
    cy.get('[type="text"]')
      .should('be.visible')
    
    // CSS: комбінація атрибутів
    cy.get('input[type="text"][placeholder*="What"]')
      .should('exist')
    
    // XPath підхід: більш складний синтаксис
    // cy.xpath('//input[@type="text"]') - знаходить input з type="text"
    // @type - синтаксис XPath для атрибутів
    cy.xpath('//input[@type="text"]')
      .should('be.visible')
    
    // Висновок: CSS простіший та читабельніший для атрибутів
  })

  // Тест 5: Складні умови - XPath перевага
  // XPath дозволяє створювати більш складні умови пошуку
  it('має показати переваги XPath для складних умов', () => {
    // Відмічаємо першу задачу як виконану
    cy.get('.todo-list li:first-child .toggle').check()
    
    // CSS підхід: потрібно комбінувати кілька селекторів
    // cy.get('.todo-list li.completed') - знаходить виконані задачі
    // Але важко знайти "першу виконану задачу" або "задачу після виконаної"
    cy.get('.todo-list li.completed')
      .should('have.length', 1)
    
    // XPath підхід: можна створити складні умови в одному виразі
    // cy.xpath('//li[contains(@class, "completed")][position()=1]') - перша виконана
    cy.xpath('//li[contains(@class, "completed")][position()=1]')
      .should('exist')
    
    // XPath: знайти задачу, яка йде після виконаної
    // Це складніше зробити через CSS
    cy.xpath('//li[contains(@class, "completed")]/following-sibling::li[1]')
      .should('exist')
    
    // Висновок: XPath потужніший для складних умов
  })

  // Тест 6: Продуктивність та читабельність
  // Важливо враховувати не тільки можливості, але й продуктивність
  it('має показати різницю в продуктивності та читабельності', () => {
    // CSS: швидший та більш читабельний
    // Браузери оптимізовані для CSS селекторів
    cy.get('.todo-list li')
      .should('have.length', 3)
    // CSS зазвичай швидший
    
    // XPath: може бути повільніший
    // XPath потребує додаткової обробки
    // Використовуємо більш загальний селектор для XPath
    cy.xpath('//ul[@class="todo-list"]//li')
      .should('have.length', 3)
    // XPath може бути повільніший для складних запитів
    
    // Висновок: CSS зазвичай швидший та читабельніший
  })
})

// ============================================================
// РЕКОМЕНДАЦІЇ: Коли використовувати CSS, а коли XPath
// ============================================================
// CSS селектори - використовуйте для:
// - Пошуку за класами, ID, атрибутами
// - Простих структурних пошуків
// - Максимальної продуктивності
// - Стандартних випадків (90% ситуацій)
//
// XPath селектори - використовуйте для:
// - Пошуку за складним текстовим вмістом
// - Складних умов з множинними критеріями
// - Навігації по складних DOM структурах
// - Випадків, коли CSS не справляється (10% ситуацій)
//
// ЗОЛОТЕ ПРАВИЛО: 
// Спочатку спробуйте CSS, якщо не виходить - використайте XPath
// ============================================================
