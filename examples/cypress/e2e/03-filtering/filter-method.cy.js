// ============================================================
// ТЕМА: Метод filter() - фільтрація елементів за умовами
// ОПИС: Демонстрація використання filter() для вибору
//       підмножини елементів, що відповідають певним умовам
// ============================================================

describe('Метод filter() - фільтрація елементів', () => {
  // Підготовка: відкриваємо сторінку та додаємо тестові дані
  beforeEach(() => {
    cy.visit('/')
    // Додаємо кілька задач для тестування фільтрації
    cy.get('.new-todo').type('Активна задача 1{enter}')
    cy.get('.new-todo').type('Активна задача 2{enter}')
    cy.get('.new-todo').type('Виконана задача{enter}')
    // Відмічаємо третю задачу як виконану
    cy.get('.todo-list li').last().find('.toggle').check()
  })

  // Тест 1: Базове використання filter()
  // filter() - фільтрує елементи за умовою, залишаючи тільки ті, що відповідають
  it('має відфільтрувати елементи за класом', () => {
    // cy.get('.todo-list li') - знаходимо всі задачі
    // .filter('.completed') - залишаємо тільки ті, що мають клас 'completed'
    // filter() працює як метод ланцюжка на вже знайдених елементах
    cy.get('.todo-list li')
      .filter('.completed')
      // Має бути тільки одна виконана задача
      .should('have.length', 1)
      // Перевіряємо, що це дійсно виконана задача
      .should('contain', 'Виконана задача')
  })

  // Тест 2: filter() з псевдокласами
  // filter() підтримує CSS псевдокласи для фільтрації за станом
  it('має використовувати filter() з псевдокласами', () => {
    // .filter(':visible') - залишаємо тільки видимі елементи
    // Це корисно, коли деякі елементи можуть бути приховані
    cy.get('.todo-list li')
      .filter(':visible')
      // Всі задачі видимі, тому має бути 3
      .should('have.length', 3)
    
    // .filter(':not(.completed)') - залишаємо тільки невиконані задачі
    // :not() - псевдоклас для виключення елементів
    cy.get('.todo-list li')
      .filter(':not(.completed)')
      // Має бути 2 активні задачі
      .should('have.length', 2)
  })

  // Тест 3: filter() з текстом
  // filter() може фільтрувати елементи за текстовим вмістом
  it('має фільтрувати елементи за текстом', () => {
    // .filter(':contains("Активна")') - залишаємо тільки елементи, що містять "Активна"
    // :contains() - jQuery селектор для пошуку за текстом
    cy.get('.todo-list li')
      .filter(':contains("Активна")')
      // Має бути 2 задачі з текстом "Активна"
      .should('have.length', 2)
    
    // .filter(':contains("Виконана")') - задачі з текстом "Виконана"
    cy.get('.todo-list li')
      .filter(':contains("Виконана")')
      .should('have.length', 1)
  })

  // Тест 4: filter() з функцією
  // filter() може приймати функцію для складнішої фільтрації
  it('має використовувати filter() з функцією', () => {
    // .filter((el) => ...) - передаємо функцію для фільтрації
    // el - це DOM елемент, потрібно обгорнути в Cypress.$() для jQuery методів
    // Важливо: функція має повертати true/false для кожного елемента
    cy.get('.todo-list li')
      .filter((el) => {
        // Перевіряємо, чи елемент містить текст "Активна"
        // el - це DOM елемент, обгортаємо в Cypress.$() для jQuery методів
        return Cypress.$(el).text().includes('Активна')
      })
      .should('have.length', 2)
    
    // Більш складний приклад - фільтрація за кількістю символів
    cy.get('.todo-list li')
      .filter((el) => {
        // Залишаємо тільки задачі, назва яких довша за 10 символів
        return Cypress.$(el).text().length > 10
      })
      .should('have.length', 3) // Всі три задачі мають назви довші за 10 символів
  })

  // Тест 5: Комбінація filter() з іншими методами
  // filter() можна комбінувати з іншими методами для складних пошуків
  it('має комбінувати filter() з іншими методами', () => {
    // Знаходимо активні задачі, потім беремо першу
    cy.get('.todo-list li')
      .filter(':not(.completed)')
      .first()
      .should('contain', 'Активна задача 1')
    
    // Знаходимо виконані задачі, потім перевіряємо їх кількість
    cy.get('.todo-list li')
      .filter('.completed')
      .should('have.length', 1)
  })

  // Тест 6: Практичний приклад - фільтрація для взаємодії
  // Використання filter() для вибору конкретних елементів для взаємодії
  it('має використовувати filter() для взаємодії з елементами', () => {
    // Знаходимо активні задачі та відмічаємо першу як виконану
    cy.get('.todo-list li')
      .filter(':not(.completed)')
      .first()
      .find('.toggle')
      .check()
    
    // Перевіряємо, що тепер є 2 виконані задачі
    cy.get('.todo-list li')
      .filter('.completed')
      .should('have.length', 2)
  })
})

// ============================================================
// ВАЖЛИВІ ЗАУВАЖЕННЯ про filter():
// ============================================================
// 1. filter() працює на вже знайдених елементах (не шукає нові)
// 2. filter() залишає тільки елементи, що відповідають умові
// 3. filter() підтримує CSS селектори та псевдокласи
// 4. filter() може приймати функцію для складнішої фільтрації
// 5. filter() не змінює порядок елементів, тільки відфільтровує
// 6. Використовуйте filter() коли потрібно вибрати підмножину елементів
// ============================================================
